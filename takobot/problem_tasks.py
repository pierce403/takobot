from __future__ import annotations

from dataclasses import dataclass
import hashlib
from pathlib import Path
import re

from .productivity import tasks as prod_tasks


@dataclass(frozen=True)
class ProblemTaskRecord:
    problem: str
    task_id: str
    title: str
    created: bool


def _normalize_problem(problem: str) -> str:
    return " ".join((problem or "").split()).strip()


def _short_problem(problem: str, *, max_chars: int = 86) -> str:
    text = _normalize_problem(problem)
    if len(text) <= max_chars:
        return text
    return text[: max_chars - 3].rstrip() + "..."


def _tagify(value: str) -> str:
    cleaned = re.sub(r"[^a-z0-9]+", "-", (value or "").strip().lower())
    cleaned = cleaned.strip("-")
    return cleaned or "issue"


def _classify_problem(problem: str) -> tuple[str, str]:
    lowered = _normalize_problem(problem).lower()

    if (
        "git identity" in lowered
        or "user.name" in lowered
        or "user.email" in lowered
        or "author identity unknown" in lowered
    ):
        return "issue-git-identity", "Configure git identity for Takobot commits"
    if "xmtp" in lowered:
        return "issue-xmtp-runtime", "Install or repair XMTP runtime dependency"
    if "inference" in lowered or "codex" in lowered or "claude" in lowered or "gemini" in lowered:
        return "issue-inference-runtime", "Diagnose and repair inference runtime"
    if "web3" in lowered:
        return "issue-web3-runtime", "Install or repair web3 runtime dependency"
    if "dns" in lowered:
        return "issue-network-dns", "Resolve network/DNS connectivity issue"
    if "writable" in lowered or "permission denied" in lowered:
        return "issue-filesystem-permissions", "Restore workspace/runtime write permissions"
    if "lock" in lowered:
        return "issue-runtime-lock", "Resolve Takobot multi-instance lock conflict"

    digest = hashlib.sha1(lowered.encode("utf-8")).hexdigest()[:10]
    return f"issue-{digest}", f"Resolve runtime issue: {_short_problem(problem)}"


def _find_open_task_by_issue_tag(repo_root: Path, issue_tag: str):
    normalized_tag = _tagify(issue_tag)
    for task in prod_tasks.list_open_tasks(repo_root):
        tags = {_tagify(tag) for tag in task.tags}
        if normalized_tag in tags:
            return task
    return None


def ensure_problem_task(repo_root: Path, problem: str, *, source: str) -> ProblemTaskRecord | None:
    normalized = _normalize_problem(problem)
    if not normalized:
        return None

    issue_tag, title = _classify_problem(normalized)
    existing = _find_open_task_by_issue_tag(repo_root, issue_tag)
    if existing is not None:
        return ProblemTaskRecord(problem=normalized, task_id=existing.id, title=existing.title, created=False)

    tags = ["runtime", "autogenerated", "problem", issue_tag]
    source_tag = _tagify(source)
    if source_tag:
        tags.append(f"source-{source_tag}")

    task = prod_tasks.create_task(
        repo_root,
        title=title,
        project="takobot-runtime",
        area="operations",
        tags=tags,
        energy="low",
    )
    return ProblemTaskRecord(problem=normalized, task_id=task.id, title=task.title, created=True)


def ensure_problem_tasks(repo_root: Path, problems: list[str], *, source: str) -> list[ProblemTaskRecord]:
    seen: set[str] = set()
    results: list[ProblemTaskRecord] = []
    for problem in problems:
        normalized = _normalize_problem(problem)
        if not normalized or normalized in seen:
            continue
        seen.add(normalized)
        record = ensure_problem_task(repo_root, normalized, source=source)
        if record is not None:
            results.append(record)
    return results
